// --- Constants ---
const GPAK        = 495;      // 5940 / 12
const VALVE_CV    = 0.5534;   // fixed valve Cv from 3.5 GPM @ 40 psi
const CHECK_CV    = 1.0360;   // fixed check-valve Cv from 6.552239 GPM @ 40 psi
const RATING_PSI  = 40;       // rating pressure for tip size (GPM @ 40 psi)

let lastSizingState = null;

// Look up the nozzle/orifice record from FLOW_DB
function getNozzleData(family, sizeKey){
  const famData = FLOW_DB[family];
  if (!famData) return null;
  return famData[sizeKey] || null;
}

// --- Cv + empirical flow helpers ---

// Tip Cv from rated flow at 40 psi (c = GPM @ 40 psi)
function tipCvFromRating(q40){
  if (!q40) return 0;
  return q40 / Math.sqrt(RATING_PSI);
}

// Total Cv of valve + tip + check in series
function totalCvForTip(tipCv){
  if (!tipCv) return 0;
  const invValve = 1 / (VALVE_CV * VALVE_CV);
  const invTip   = 1 / (tipCv * tipCv);
  const invCheck = 1 / (CHECK_CV * CHECK_CV);
  return 1 / Math.sqrt(invValve + invTip + invCheck);
}

// Nozzle (tip) pressure from boom/gauge pressure using series Cv physics
function nozzlePressureFromGauge(Pb, tipCv){
  if (!Pb || !tipCv) return 0;
  const cvTotal = totalCvForTip(tipCv);
  if (!cvTotal) return 0;
  const qStack = cvTotal * Math.sqrt(Pb);   // flow through stack at boom psi
  const ratio  = qStack / tipCv;           // Q = Cv_tip * sqrt(P_noz)
  return ratio * ratio;                    // P_noz = (Q / Cv_tip)^2
}

// Empirical nozzle flow from A/B data at a given nozzle pressure
function nozzleFlowEmpirical(Pn, coeff){
  if (!Pn || !coeff) return 0;
  // Q = a * P^b  (a,b from FLOW_DB)
  return coeff.a * Math.pow(Pn, coeff.b);
}









// Duty cycle target & quality bands (internal only)
const DC_OPT      = 75;  // target %
const DC_GOOD_LO  = 60;  // "good" band lower
const DC_GOOD_HI  = 100; // "good" band upper

// Aircraft → base nozzle count (no T-Boom)
const NOZZLE_BASE = {
  "AT-402": 94,
  "AT-502": 94,
  "AT-602": 106,
  "AT-802": 106
};

// Flow model from 2022 High Speed Spray Nozzle Models:
// Q(gpm) = a * P^b  (clamped by Cv)
const FLOW_DB = {
  "CP11TT 20° Flat Fan": {
    "4":  { a: 0.06636,  b: 0.48843,   c: 0.4,   d: 0.06,      e: 0.06,      F: 0.48  },
    "6":  { a: 0.095,    b: 0.4987,    c: 0.6,   d: 0.10,      e: 0.10,      F: 0.71  },
    "8":  { a: 0.124635, b: 0.50334,   c: 0.8,   d: 0.13,      e: 0.13,      F: 0.93  },
    "10": { a: 0.14959,  b: 0.51898,   c: 1.0,   d: 0.16,      e: 0.15,      F: 1.14  },
    "12": { a: 0.179398, b: 0.518838,  c: 1.2,   d: 0.19,      e: 0.18,      F: 1.35  },
    "15": { a: 0.23569,  b: 0.50193,   c: 1.5,   d: 0.24,      e: 0.22,      F: 1.62  },
    "20": { a: 0.31353,  b: 0.50233,   c: 2.0,   d: 0.32,      e: 0.27,      F: 2.02  }
  },

  "CP11TT 40° Flat Fan": {
    "4":  { a: 0.06636,  b: 0.48843,   c: 0.4,   d: 0.06,      e: 0.06,      F: 0.48  },
    "6":  { a: 0.095,    b: 0.4987,    c: 0.6,   d: 0.10,      e: 0.10,      F: 0.71  },
    "8":  { a: 0.124635, b: 0.50334,   c: 0.8,   d: 0.13,      e: 0.13,      F: 0.93  },
    "10": { a: 0.14959,  b: 0.51898,   c: 1.0,   d: 0.16,      e: 0.15,      F: 1.14  },
    "12": { a: 0.179398, b: 0.518838,  c: 1.2,   d: 0.19,      e: 0.18,      F: 1.35  },
    "15": { a: 0.23569,  b: 0.50193,   c: 1.5,   d: 0.24,      e: 0.22,      F: 1.62  },
    "20": { a: 0.31353,  b: 0.50233,   c: 2.0,   d: 0.32,      e: 0.27,      F: 2.02  },
    "25": { a: 0.37909,  b: 0.51492,   c: 2.5,   d: 0.41,      e: 0.31,      F: 2.34  },
    "30": { a: 0.4529,   b: 0.51599,   c: 3.0,   d: 0.49,      e: 0.35,      F: 2.59  }
  },

  "CP11TT 80° Flat Fan": {
    "2":  { a: 0.03263,  b: 0.4881,    c: 0.2,   d: 0.03,      e: 0.03,      F: 0.24  },
    "3":  { a: 0.04529,  b: 0.51365,   c: 0.3,   d: 0.05,      e: 0.05,      F: 0.36  },
    "4":  { a: 0.06636,  b: 0.48843,   c: 0.4,   d: 0.06,      e: 0.06,      F: 0.48  },
    "5":  { a: 0.077843, b: 0.50352,   c: 0.5,   d: 0.08,      e: 0.08,      F: 0.59  },
    "6":  { a: 0.095,    b: 0.4987,    c: 0.6,   d: 0.10,      e: 0.10,      F: 0.71  },
    "8":  { a: 0.124635, b: 0.50334,   c: 0.8,   d: 0.13,      e: 0.13,      F: 0.93  },
    "10": { a: 0.14959,  b: 0.51898,   c: 1.0,   d: 0.16,      e: 0.15,      F: 1.14  },
    "12": { a: 0.179398, b: 0.518838,  c: 1.2,   d: 0.19,      e: 0.18,      F: 1.35  },
    "15": { a: 0.23569,  b: 0.50193,   c: 1.5,   d: 0.24,      e: 0.22,      F: 1.62  },
    "20": { a: 0.31353,  b: 0.50233,   c: 2.0,   d: 0.32,      e: 0.27,      F: 2.02  },
    "25": { a: 0.37909,  b: 0.51492,   c: 2.5,   d: 0.41,      e: 0.31,      F: 2.34  },
    "30": { a: 0.4529,   b: 0.51599,   c: 3.0,   d: 0.49,      e: 0.35,      F: 2.59  }
  },

  "CP03": {
    "0.062": { a: 0.06793,   b: 0.578697, c: 0.0062, d: 0.00,     e: 0.00,     F: 0.01 },
    "0.078": { a: 0.15414,   b: 0.49788,  c: 0.0078, d: 0.00,     e: 0.00,     F: 0.01 },
    "0.125": { a: 0.38875,   b: 0.516055, c: 0.0125, d: 0.00,     e: 0.00,     F: 0.02 },
    "0.172": { a: 0.808131,  b: 0.460811, c: 0.0172, d: 0.00,     e: 0.00,     F: 0.02 }
  },

  "Steel Disc Core 45": {
    "2":  { a: 0.034075,  b: 0.48441,  c: 0.2,  d: 0.03,     e: 0.03,     F: 0.24 },
    "4":  { a: 0.058842,  b: 0.48849,  c: 0.4,  d: 0.06,     e: 0.06,     F: 0.48 },
    "6":  { a: 0.0870798, b: 0.514586, c: 0.6,  d: 0.10,     e: 0.10,     F: 0.71 },
    "8":  { a: 0.122721,  b: 0.521397, c: 0.8,  d: 0.13,     e: 0.13,     F: 0.93 },
    "10": { a: 0.159157,  b: 0.52275,  c: 1.0,  d: 0.16,     e: 0.15,     F: 1.14 },
    "12": { a: 0.196716,  b: 0.523962, c: 1.2,  d: 0.19,     e: 0.18,     F: 1.35 },
    "14": { a: 0.230042,  b: 0.51369,  c: 1.4,  d: 0.23,     e: 0.21,     F: 1.53 },
    "16": { a: 0.25906,   b: 0.523529, c: 1.6,  d: 0.26,     e: 0.23,     F: 1.71 }
  },

  "Ceramic Disc Core 45": {
    "2":  { a: 0.034075,  b: 0.48441,  c: 0.2,  d: 0.03,     e: 0.03,     F: 0.24 },
    "4":  { a: 0.058842,  b: 0.48849,  c: 0.4,  d: 0.06,     e: 0.06,     F: 0.48 },
    "6":  { a: 0.0870798, b: 0.514586, c: 0.6,  d: 0.10,     e: 0.10,     F: 0.71 },
    "8":  { a: 0.122721,  b: 0.521397, c: 0.8,  d: 0.13,     e: 0.13,     F: 0.93 },
    "10": { a: 0.159157,  b: 0.52275,  c: 1.0,  d: 0.16,     e: 0.15,     F: 1.14 }
  },

  "Standard 40° Flat Fan": {
    "2":  { a: 0.029049, b: 0.519085,  c: 0.2,  d: 0.03,     e: 0.03,     F: 0.24 },
    "4":  { a: 0.065176, b: 0.493859,  c: 0.4,  d: 0.06,     e: 0.06,     F: 0.48 },
    "6":  { a: 0.093974, b: 0.502175,  c: 0.6,  d: 0.10,     e: 0.10,     F: 0.71 },
    "8":  { a: 0.118101, b: 0.5616622, c: 0.8,  d: 0.13,     e: 0.13,     F: 0.93 },
    "10": { a: 0.15286,  b: 0.507496,  c: 1.0,  d: 0.16,     e: 0.15,     F: 1.14 },
    "12": { a: 0.176754, b: 0.51711,   c: 1.2,  d: 0.19,     e: 0.18,     F: 1.35 },
    "15": { a: 0.22734,  b: 0.509427,  c: 1.5,  d: 0.24,     e: 0.22,     F: 1.62 },
    "20": { a: 0.29049,  b: 0.519085,  c: 2.0,  d: 0.32,     e: 0.27,     F: 2.02 },
    "25": { a: 0.40032,  b: 0.494927,  c: 2.5,  d: 0.41,     e: 0.31,     F: 2.34 },
    "30": { a: 0.49563,  b: 0.494927,  c: 3.0,  d: 0.49,     e: 0.35,     F: 2.59 }
  },

  "Standard 80° Flat Fan": {
    "2":  { a: 0.029049, b: 0.519085,  c: 0.2,  d: 0.03,     e: 0.03,     F: 0.24 },
    "4":  { a: 0.065176, b: 0.493859,  c: 0.4,  d: 0.06,     e: 0.06,     F: 0.48 },
    "6":  { a: 0.093974, b: 0.502175,  c: 0.6,  d: 0.10,     e: 0.10,     F: 0.71 },
    "8":  { a: 0.118101, b: 0.5616622, c: 0.8,  d: 0.13,     e: 0.13,     F: 0.93 },
    "10": { a: 0.15286,  b: 0.507496,  c: 1.0,  d: 0.16,     e: 0.15,     F: 1.14 },
    "12": { a: 0.176754, b: 0.51711,   c: 1.2,  d: 0.19,     e: 0.18,     F: 1.35 },
    "15": { a: 0.22734,  b: 0.509427,  c: 1.5,  d: 0.24,     e: 0.22,     F: 1.62 },
    "20": { a: 0.29049,  b: 0.519085,  c: 2.0,  d: 0.32,     e: 0.27,     F: 2.02 },
    "25": { a: 0.40032,  b: 0.494927,  c: 2.5,  d: 0.41,     e: 0.31,     F: 2.34 },
    "30": { a: 0.49563,  b: 0.488603,  c: 3.0,  d: 0.49,     e: 0.35,     F: 2.59 }
  },

  "CP11TT Straight Stream": {
    "6":  { a: 0.095,    b: 0.4987,   c: 0.6,   d: 0.10,     e: 0.10,     F: 0.71 },
    "8":  { a: 0.124635, b: 0.50334,  c: 0.8,   d: 0.13,     e: 0.13,     F: 0.93 },
    "10": { a: 0.14959,  b: 0.51898,  c: 1.0,   d: 0.16,     e: 0.15,     F: 1.14 },
    "12": { a: 0.179398, b: 0.518838, c: 1.2,   d: 0.19,     e: 0.18,     F: 1.35 },
    "15": { a: 0.23569,  b: 0.50193,  c: 1.5,   d: 0.24,     e: 0.22,     F: 1.62 },
    "20": { a: 0.31353,  b: 0.50233,  c: 2.0,   d: 0.32,     e: 0.27,     F: 2.02 },
    "25": { a: 0.37909,  b: 0.51492,  c: 2.5,   d: 0.41,     e: 0.31,     F: 2.34 }
  },

  "Disc Core Straight Stream": {
    "2":  { a: 0.01942,  b: 0.63425,  c: 0.2,   d: 0.03,     e: 0.03,     F: 0.24 },
    "3":  { a: 0.03432,  b: 0.55706,  c: 0.3,   d: 0.05,     e: 0.05,     F: 0.36 },
    "4":  { a: 0.06428,  b: 0.5288,   c: 0.4,   d: 0.06,     e: 0.06,     F: 0.48 },
    "5":  { a: 0.11855,  b: 0.49621,  c: 0.5,   d: 0.08,     e: 0.08,     F: 0.59 },
    "6":  { a: 0.2,      b: 0.44944,  c: 0.6,   d: 0.10,     e: 0.10,     F: 0.71 },
    "7":  { a: 0.22658,  b: 0.495038, c: 0.7,   d: 0.11,     e: 0.11,     F: 0.82 },
    "8":  { a: 0.35376,  b: 0.44997,  c: 0.8,   d: 0.13,     e: 0.13,     F: 0.93 },
    "10": { a: 0.47806,  b: 0.47081,  c: 1.0,   d: 0.16,     e: 0.15,     F: 1.14 },
    "12": { a: 0.56108,  b: 0.49034,  c: 1.2,   d: 0.19,     e: 0.18,     F: 1.35 }
  },

  "Davidon TriSet": {
    "0.061": { a: 0.107668, b: 0.494927, c: 0.0061, d: 0.00,    e: 0.00,    F: 0.01 },
    "0.078": { a: 0.171653, b: 0.488799, c: 0.0078, d: 0.00,    e: 0.00,    F: 0.01 },
    "0.125": { a: 0.381699, b: 0.500123, c: 0.0125, d: 0.00,    e: 0.00,    F: 0.02 }
  },

  "CP09": {
    "0.062": { a: 0.06793,   b: 0.578697, c: 0.57,  d: 0.09,    e: 0.09,    F: 0.67 },
    "0.078": { a: 0.15414,   b: 0.49788,  c: 0.97,  d: 0.16,    e: 0.15,    F: 1.11 },
    "0.125": { a: 0.38875,   b: 0.516055, c: 2.61, d: 0.42,    e: 0.32,    F: 2.40 },
    "0.172": { a: 0.808131,  b: 0.460811, c: 4.42, d: 0.72,    e: 0.41,    F: 3.04 }
  },

  "TeeJet SS": {
    "2":  { a: 0.031243,   b: 0.501353,  c: 0.2,  d: 0.03,    e: 0.03,    F: 0.24 },
    "3":  { a: 0.046759,   b: 0.503775,  c: 0.3,  d: 0.05,    e: 0.05,    F: 0.36 },
    "4":  { a: 0.0622774,  b: 0.5049686, c: 0.4,  d: 0.06,    e: 0.06,    F: 0.48 },
    "6":  { a: 0.09351724, b: 0.5037751, c: 0.6,  d: 0.10,    e: 0.10,    F: 0.71 },
    "8":  { a: 0.127919,   b: 0.4967165, c: 0.8,  d: 0.13,    e: 0.13,    F: 0.93 },
    "10": { a: 0.158941,   b: 0.501353,  c: 1.0,  d: 0.16,    e: 0.15,    F: 1.14 },
    "12": { a: 0.216582,   b: 0.467888,  c: 1.2,  d: 0.19,    e: 0.18,    F: 1.35 },
    "15": { a: 0.236942,   b: 0.503775,  c: 1.5,  d: 0.24,    e: 0.22,    F: 1.62 },
    "20": { a: 0.314942,   b: 0.5049686, c: 2.0,  d: 0.32,    e: 0.27,    F: 2.02 },
    "25": { a: 0.405553553,b: 0.494927,  c: 2.5,  d: 0.41,    e: 0.31,    F: 2.34 },
    "30": { a: 0.486664263,b: 0.494927,  c: 3.0,  d: 0.49,    e: 0.35,    F: 2.59 }
  },

  "TeeJet H1 4U": {
    "2":  { a: 0.031243,   b: 0.501353,  c: 0.2,  d: 0.03,    e: 0.03,    F: 0.24 },
    "3":  { a: 0.046759,   b: 0.503775,  c: 0.3,  d: 0.05,    e: 0.05,    F: 0.36 },
    "4":  { a: 0.0622774,  b: 0.5049686, c: 0.4,  d: 0.06,    e: 0.06,    F: 0.48 },
    "6":  { a: 0.09351724, b: 0.5037751, c: 0.6,  d: 0.10,    e: 0.10,    F: 0.71 },
    "8":  { a: 0.127919,   b: 0.4967165, c: 0.8,  d: 0.13,    e: 0.13,    F: 0.93 },
    "10": { a: 0.158941,   b: 0.499091,  c: 1.0,  d: 0.16,    e: 0.15,    F: 1.14 },
    "12": { a: 0.216582,   b: 0.467888,  c: 1.2,  d: 0.19,    e: 0.18,    F: 1.35 },
    "15": { a: 0.236942,   b: 0.50032,   c: 1.5,  d: 0.24,    e: 0.22,    F: 1.62 },
    "20": { a: 0.314942,   b: 0.5009387, c: 2.0,  d: 0.32,    e: 0.27,    F: 2.02 },
	"25": { a: 0.405553553,b: 0.494927,  c: 2.5,  d: 0.41,    e: 0.31,    F: 2.34 },
    "30": { a: 0.486664263,b: 0.494927,  c: 3.0,  d: 0.49,    e: 0.35,    F: 2.59 }
  }
};

const DROPLET_DB = {
  "CP11TT 20\u00b0 Flat Fan": {
    ccd: { orfSub: 12, orfDiv: 8, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 45, angDiv: 45 },
    dv01: [87.494915254, 14.505555556, -28.45555556, 6.2888888889, -49.25, -6.1125, 3.3125, 1.9125, -4.55, 14.6, -6.125, -4.82740113, 4.8225988701, 0.9225988701, 15.67259887],
    dv05: [217.38305085, 34.122222222, -62.21111111, 12.2, -104.9611111, -16.7, 8.9875, 1.5375, -17.7, 35.775, -20.7375, -6.346892655, 13.253107345, 1.2531073446, 28.403107345],
    dv09: [382.3559322, 85.55, -115.9388889, 26, -213.8277778, -28.0375, 15.425, 0.5, -52.4875, 67.0375, -43.6, -6.365254237, 27.834745763, 5.1847457627, 63.434745763],
    vlt100: [12.829813559, -3.445888889, 6.0168888889, 0.4987777778, 11.765166667, -0.5895625, -0.5198125, 0.0324375, -2.4668125, 2.8744375, 1.8526875, 1.8307175141, 0.0907175141, -0.319282486, 2.9382175141],
    vlt200: [44.247457627, -6.683333333, 12.772222222, -0.661111111, 26.166666667, 0.35, -0.1, -2.2625, -2.1, 1.0375, 3.8625, 2.861299435, -0.438700565, -1.038700565, 3.011299435],
    orifices: [4, 6, 8, 10, 12, 15, 20],
    angles: [0, 15, 30, 45, 60, 75, 90]
  },
  "CP11TT 40\u00b0 Flat Fan": {
    ccd: { orfSub: 17, orfDiv: 13, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 45, angDiv: 45 },
    dv01: [82.848660331, 9.84709259, -24.89310981, 2.0624830853, -42.54191849, -5.981007147, 3.2890939418, -0.059645835, -3.618982088, 16.889645831, -7.753937499, -7.574678223, 3.029208108, 0.236374758, 16.876541423],
    dv05: [208.43403287, 30.961425935, -57.69716513, 6.093937279, -93.13301071, -16.71141049, 9.1006634914, -0.349000002, -13.47837656, 33.788249998, -18.14216666, -20.3662598, 10.175744796, -1.959088504, 35.384744846],
    dv09: [368.04124037, 82.723611133, -106.5265994, 17.959243762, -189.7159967, -30.69772993, 21.624592332, -8.862187519, -48.86138995, 60.522979181, -41.84106251, -38.30284397, 27.128274974, -5.021058376, 79.432774974],
    vlt100: [14.305937127, -3.823322166, 6.3481208565, 1.2594098714, 12.849533836, -1.096792416, 0.029361681, -0.244638063, -3.090121511, 2.2643513539, 2.3896116456, 3.302282473, 0.320777366, -0.357917634, 2.426008531],
    vlt200: [49.092798149, -6.652758482, 12.975048903, 0.8416975362, 25.967329269, 0.3919356295, 0.3909305129, -2.703123541, -2.617470314, -0.875733249, 4.0473404987, 6.8747766744, -0.269282238, -1.041777908, -1.830584738],
    orifices: [4, 6, 8, 10, 12, 15, 20, 25, 30],
    angles: [0, 15, 30, 45, 60, 75, 90]
  },
  "CP11TT 80\u00b0 Flat Fan": {
    ccd: { orfSub: 16, orfDiv: 14, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 45, angDiv: 45 },
    dv01: [80.391078099, 15.380074074, -19.14014325, 0.0056695668, -24.75770925, -7.02971596, 1.7830325255, 0.3822500044, -8.585032673, 7.8308749994, -2.382166663, -13.02319862, 2.7539896355, -0.801510344, 9.3966563005],
    dv05: [198.73514287, 40.907833335, -41.15219441, 0.2702917236, -53.59343925, -16.12449653, 4.8200907635, 2.9197708269, -21.86734512, 13.451437498, -4.929104173, -29.74704027, 5.9512184929, -2.730781557, 17.852551793],
    dv09: [345.2431166, 87.858425917, -66.27101267, 3.2715841732, -110.8328236, -23.32559582, 11.597938924, 12.210354175, -52.55243671, 19.381437513, -15.22756249, -55.80807989, 8.0830904113, -9.317742939, 48.949757061],
    vlt100: [16.110514628, -6.648688611, 7.817833935, 0.5549789616, 9.947956556, -1.526330193, -0.384342173, 0.2859098336, -1.652032616, 2.6523377914, 1.0362045836, 6.4252147624, -0.362790111, -1.242262445, 1.7483865551],
    vlt200: [52.983175431, -13.3, 13.280223088, 0.7957259207, 18.074699008, 1.7081090652, -1.238533994, -2.29375, 3.1120750708, -0.23125, 1.53125, 12.10100536, -0.910734463, -1.360734463, -0.460734463],
    orifices: [2, 3, 4, 5, 6, 8, 10, 12, 15, 20, 25, 30],
    angles: [0, 15, 30, 45, 60, 75, 90]
  },
  "CP03": {
    ccd: { orfSub: 0.1165, orfDiv: 0.0555, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 60, angDiv: 30 },
    dv01: [82.877201228, 3.2460531718, -22.57192844, -1.953681671, -15.81245226, -2.540138834, 1.4491383927, 1.2688852088, 0.597843129, 4.9491893466, -1.766251508, 5.1945823608, 2.5749497494, 0.5648417795, -5.332182448],
    dv05: [198.7792553, 16.367491422, -52.6884686, 1.9102673149, -35.60040998, -8.450838409, 2.8141469957, -0.926123868, 0.1724330552, 10.71232423, -4.657699683, 1.4505102005, 8.9316969545, 1.0120970241, -3.840227246],
    dv09: [359.34207523, 50.517415518, -109.3463618, 25.823960104, -84.97819099, -23.96242861, 4.1525234699, -28.36083748, 5.8988553969, 18.742960233, -7.831338065, -14.64847387, 29.248472138, 26.839737649, -13.89836775],
    vlt100: [14.272675155, -1.537438156, 7.4053570797, 0.6418695816, 5.4638877882, 0.0446177894, -0.55248316, -0.245823302, -1.211125882, 1.4614514557, 0.8700299276, -0.221912192, 1.0716949525, -0.032098969, 2.0995617394],
    vlt200: [50.431251076, -6.045324862, 18.301926504, 0.6527718814, 13.091333408, 0.747419973, -2.408190247, 0.0866756716, -1.740865709, 1.4072669382, 1.8963675713, 1.5619571255, -0.832278715, -1.408636426, 4.4746342418],
    orifices: [0.062, 0.078, 0.125, 0.172],
    angles: [30, 55, 90]
  },
  "Steel Disc Core 45": {
    ccd: { orfSub: 9, orfDiv: 7, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 45, angDiv: 45 },
    dv01: [71.079884258, 6.4082777783, -17.77781759, -0.984157145, -8.495773095, -4.146508201, 0.8324331648, 1.1640416675, 0.3771283006, -1.0905, -1.537041666, -2.476474653, 3.6690338955, -0.672299434, -3.471799434],
    dv05: [179.45388348, 23.301574087, -35.55823255, -2.027162809, -18.69019354, -11.82131797, -0.553923165, 3.4291458438, 3.7223074031, -0.289395835, -2.197395831, -14.56585429, 4.3920376415, -0.897962309, -8.319129009],
    dv09: [350.50486188, 54.763425917, -63.14502177, -0.390516869, -21.39412019, -23.70920523, -0.515563076, 5.0488541562, 18.212261221, 2.3433958437, -2.641729169, -34.52208127, 8.2467975613, 3.8306308613, -44.75820244],
    vlt100: [18.246711896, -5.525358221, 10.462539817, 0.5944275289, 6.5837653661, -1.002647218, -0.391000712, -0.634345729, -3.276052796, 3.925032646, 1.3770364794, 3.1592761399, 1.5166618879, 0.1878945579, 3.0439607229],
    vlt200: [57.475694444, -10.61666667, 14.423020362, 0.4331447964, 7.2041855204, 4.6002828054, 0.3381221719, -1.91875, -2.886312217, -1.06875, 1.14375, 7.6827801318, -0.690677966, 0.4093220339, 4.6093220339],
    orifices: [2, 4, 6, 8, 10, 12, 14, 16],
    angles: [0, 15, 30, 45, 60, 75, 90]
  },
  "Ceramic Disc Core 45": {
    ccd: { orfSub: 6, orfDiv: 4, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 45, angDiv: 45 },
    dv01: [71.184694916, 10.061814816, -17.17031482, 0.8224259244, -12.48901852, -6.517854168, -1.728770836, 1.8056875019, -1.596854169, 1.0687708356, 0.8396875031, -1.456199622, 3.1029670427, -2.196699622, 0.3669670427],
    dv05: [176.94510733, 27.351351868, -37.03585185, 1.7993148128, -27.82937036, -13.51283333, -3.033375008, 4.5241249956, -3.721250004, 1.5206666669, 1.3641249956, -10.71856968, 4.0172636658, -3.990569684, -0.365736334],
    dv09: [333.15811301, 57.961833344, -69.99429629, 7.7273518556, -47.54424074, -29.89302084, 1.2960625, 6.4148958375, -4.089937513, 4.5010625, 1.0617291625, -26.86152076, 9.0126459441, 0.0108126441, -27.20352071],
    vlt100: [18.944263344, -6.752275779, 10.195134944, -1.773000037, 8.4180711491, -1.217860417, 1.4037392077, -0.964485875, -2.962515335, 4.4679277498, -1.124719625, 2.7165237673, 1.6514095973, 0.6134794323, 1.6507387623],
    vlt200: [59.477966102, -11.06666667, 14.888888889, -0.927777778, 11.111111111, 4.8375, 0.45, -2.1875, 0.025, 0.2375, 0.375, 5.609039548, -0.190960452, 1.359039548, 2.009039548],
    orifices: [2, 4, 6, 8, 10],
    angles: [0, 15, 30, 45, 60, 75, 90]
  },
  "Standard 40\u00b0 Flat Fan": {
    ccd: { orfSub: 16, orfDiv: 14, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 45, angDiv: 45 },
    dv01: [85.604962314, 9.5838055572, -22.16106126, -0.567469079, -38.6736771, -6.518886246, 2.0607291963, 4.1763437519, -1.110815476, 10.960260411, -2.947197919, -6.716207603, 0.1304496168, -2.835050368, 14.278949617],
    dv05: [223.09979292, 39.613916668, -52.04873394, 2.7981742856, -80.80058289, -18.29364178, 3.1661266779, 6.7144687519, -11.79494423, 20.869218748, -9.855197923, -27.79186492, 3.3159957375, -7.111337562, 24.209829088],
    dv09: [401.7904672, 95.066101844, -86.99491956, 13.964785602, -165.139596, -23.78403029, 8.1268211123, 14.574385413, -41.66559211, 32.228968762, -31.81232291, -53.47372382, 0.5432038497, -6.80312945, 60.29637055],
    vlt100: [12.981614618, -5.833300658, 8.0024463149, 0.3476283493, 14.193920816, -1.900799785, 0.3701911221, -0.436633697, -5.623381137, 4.3428516352, 1.2063513018, 3.4956393491, 2.0858292933, 0.8585216268, 2.6107221268],
    vlt200: [45.491105097, -9.648525741, 13.035434228, 0.3732950844, 23.733092411, 1.5179273898, 0.4403222576, -3.294778353, -3.140545033, -0.462337604, 2.9421637294, 8.1139141765, 1.1967205751, -1.09152392, 1.0251279101],
    orifices: [2, 4, 6, 8, 10, 12, 15, 20, 30],
    angles: [0, 15, 30, 45, 60, 75, 90]
  },
  "Standard 80\u00b0 Flat Fan": {
    ccd: { orfSub: 16, orfDiv: 14, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 45, angDiv: 45 },
    dv01: [80.832058699, 9.1461851856, -17.19349041, -1.663129579, -29.1637008, -6.203125685, 1.1153396083, 2.2329583337, -3.0049678, 7.06583333, -1.683041666, -6.363329885, 0.9181016907, -4.621398304, 7.9517683607],
    dv05: [206.79402133, 36.078703707, -40.26813286, -2.297706658, -60.08264631, -15.15307236, 2.6012930438, 6.3497708419, -13.82010116, 12.069479154, -4.916979171, -27.61925296, 5.3175452101, -8.30078814, 12.74071186],
    dv09: [370.77552377, 83.113740739, -67.99461483, -0.973534978, -124.2546288, -21.66546947, 4.6599265989, 14.216562494, -42.08856372, 18.607354156, -15.74427083, -60.15489849, 13.00837662, -18.22229003, 37.00270997],
    vlt100: [14.753198352, -5.985391259, 8.0091987727, 0.8412886057, 13.317366751, -1.561509236, -0.39705694, -0.042997395, -4.404653002, 3.9477741458, 1.1571144367, 4.0674583733, 1.5791860876, 1.2884727576, 2.4197692541],
    vlt200: [50.42982117, -10.995825, 12.148043933, 1.5038168818, 20.653530967, 2.1091289488, 0.0059257319, -3.583903333, 0.6085315536, -0.518259249, 2.0323964994, 10.449127753, -0.01602319, -0.12264686, 1.0434813048],
    orifices: [2, 4, 6, 8, 10, 12, 15, 20, 30],
    angles: [0, 15, 30, 45, 60, 75, 90]
  },
  "CP09": {
    ccd: { orfSub: 0.117, orfDiv: 0.055, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 15, angDiv: 15 },
    dv01: [62.275938268, -5.061593839, -41.38493853, 11.461160907, -37.45180122, 4.9437584213, -11.39164729, -13.51023316, 10.83256967, 14.03421454, -10.24010557, -2.758076926, 14.044497468, 3.5972472764, 54.385405907],
    dv05: [109.20698622, -10.94659487, -112.5253385, 44.397913063, -114.8312667, 18.040915935, -38.10777543, -48.8316896, 27.667624325, 41.800159793, -32.80224909, -12.36069891, 43.648151047, 13.788941252, 190.57346423],
    dv09: [300.88481974, 25.451474081, -214.0946506, 94.439782321, -208.9856681, 21.547193896, -56.61608309, -122.74202, 36.393501496, 69.867763824, -55.29595045, 18.638446549, 91.234112198, 52.827381044, 199.74458737],
    vlt100: [10.936440684, -0.740542971, 5.4778441001, -0.254027237, 4.139637644, -0.033450594, -0.32826793, 0.1671021265, -1.433369782, 0.9586654818, 0.3366976549, -0.190145433, 1.2460524442, 0.0550896026, -1.85658382],
    vlt200: [41.069939814, -3.40734368, 16.284497505, -2.145513289, 13.246873853, -0.746783807, -0.542499241, 0.552321803, -4.679794457, 2.4996804484, 0.396778611, 0.3070308566, 1.949876885, -1.185733918, -7.151724713],
    orifices: [0.062, 0.078, 0.125, 0.172],
    angles: [0, 5, 30]
  },
  "CP11TT Straight Stream": {
    ccd: { orfSub: 15.5, orfDiv: 9.5, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 22.5, angDiv: 22.5 },
    dv01: [119.45347458, -10.18718519, -54.71966667, 21.508518519, -52.89233333, 3.4273333333, -1.829166667, -12.08825, 14.614958333, 28.336208333, -20.24145833, 3.744779661, 15.786779661, 0.981779661, 7.3041129944],
    dv05: [291.09035311, -14.87280556, -127.5480648, 59.55012037, -123.687713, 7.43434375, -8.568739583, -37.51092708, 27.652302083, 64.702447917, -53.62630208, 7.1775324859, 39.118699153, 2.8443658192, 18.815199153],
    dv09: [568.66599435, -9.186925926, -233.8423148, 126.42764815, -240.1379444, 2.839625, -23.45329167, -90.154875, 48.171083333, 112.01141667, -117.52575, 28.21839548, 92.33589548, -2.669437853, -2.392771186],
    vlt100: [6.7955127571, 0.1697737407, 5.3290549815, -1.133546593, 4.7546889815, 0.1865588542, 0.1514333125, -0.496685187, -1.136621188, 1.8709139792, 0.5040265208, -0.143659772, 0.9768263945, 0.2841995612, 1.5699617279],
    vlt200: [26.355134596, 0.2020105278, 15.249431898, -3.768493991, 13.968060324, 0.0579539688, 0.3733555521, -0.999832469, -3.15536799, 3.5761391563, 1.8835790729, -0.509847473, 1.6994086935, 0.7768793602, 2.9733295268],
    orifices: [6, 8, 10, 12, 15, 20, 25],
    angles: [0, 15, 30, 45]
  },
  "Disc Core Straight Stream": {
    ccd: { orfSub: 7, orfDiv: 5, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 22.5, angDiv: 22.5 },
    dv01: [127.19018078, -13.25509259, -57.61296297, 17.342740738, -56.94357407, 6.3485625, -3.402020834, -9.123187501, 23.840479163, 33.349645838, -16.26735417, -16.081822, 16.305011301, 2.3866779511, 17.420177951],
    dv05: [316.82802823, -18.51666667, -131.2386111, 46.8677037, -123.7915556, 11.724083338, -9.731, -26.86829168, 39.621541663, 68.337416663, -39.45908333, -34.77031072, 37.875855929, 1.0886892791, 34.036355929],
    dv09: [635.75337287, 12.314722233, -246.1202778, 112.56466668, -228.9845741, 12.034854144, -10.61564581, -76.51277084, 44.084854144, 127.35414586, -102.1506042, -69.10060169, 72.282398306, 13.526564956, 19.039398356],
    vlt100: [6.1290797513, -0.28723137, 5.4576151483, -0.886364833, 4.8854923521, 0.3240639378, 0.254286479, -0.330180063, -2.000596646, 1.5152539794, 0.4485197706, 2.0752819565, 0.775467957, -0.001570876, 1.07916779],
    vlt200: [24.02855843, -0.434827315, 15.336443593, -3.314160815, 14.017457557, 0.4764372083, 1.0032365833, -0.998642917, -5.04622625, 2.6460403346, 1.1994623746, 5.4332003347, 1.2741814997, 0.1732201647, 1.0819208297],
    orifices: [2, 3, 4, 5, 6, 7, 8, 10, 12],
    angles: [0, 15, 30, 45]
  },
  "Davidon TriSet": {
    ccd: { orfSub: 0.0935, orfDiv: 0.0315, asSub: 150, asDiv: 30, pressSub: 60, pressDiv: 30, angSub: 22.5, angDiv: 22.5 },
    dv01: [102.5435005, -7.711244887, -58.01604157, 26.94461891, -67.51026087, -0.986010739, 20.201801034, -18.1157006, 4.3086751906, 45.409260551, -30.80488274, 2.7622827831, 13.101688969, -0.320639367, 30.567855634],
    dv05: [242.74261409, -4.428274949, -134.3128712, 74.368059007, -167.4649469, -8.149670679, 55.851754954, -47.41769484, 5.6828734478, 105.09984936, -82.37988859, -3.709194019, 30.620968771, 2.6140818931, 92.303635371],
    dv09: [451.53927512, 12.210556247, -216.9586316, 133.86712049, -307.6643335, -9.446844495, 90.737486613, -79.06489045, -3.383543943, 162.52478756, -144.683443, -16.09626762, 53.057731558, -0.429158277, 151.83356491],
    vlt100: [8.9159307912, 0.706834728, 5.2315287102, -0.839318067, 6.2734262704, 0.2246505527, 0.6276880815, -0.38842854, -0.114724855, 1.4306817072, 0.9431512066, 0.8016518953, 0.5719569552, -0.2824627, 0.6325026252],
    vlt200: [35.254811329, 0.5352385674, 15.698883723, -3.703134695, 19.682623731, -0.178762987, 1.5891734994, -1.25590204, -1.486738458, 2.8963608546, 2.5799197891, 2.7756460452, 0.0954994956, -0.443665318, -2.006839834],
    orifices: [0.061, 0.078, 0.125],
    angles: [0, 22.5, 45]
  },
  "CP11TT 60\u00b0 Flat Fan": {
    ccd: { orfSub: 0, orfDiv: 1, asSub: 150, asDiv: 30, pressSub: 45, pressDiv: 15, angSub: 45, angDiv: 45 },
    dv01: [75.652333333, 0, -28.41885833, 1.064175, -26.52804167, 0, 0, -1.3158625, 0, 11.885575, -1.856304167, 0, 2.3082875, -0.069483333, 11.7432875],
    dv05: [187.66, 0, -62.6289, 2.7915, -61.2409, 0, 0, -2.696983333, 0, 26.700933333, -5.906183333, 0, 5.3273833333, 1.3803, 27.344216667],
    dv09: [343.03366667, 0, -105.2179667, 4.9952333333, -154.4741667, 0, 0, -11.94063333, 0, 42.47595, -13.19711667, 0, 5.9071833333, 7.0720166667, 83.746933333],
    vlt100: [16.579871, 0, 8.942846175, -0.315860958, 7.8103552917, 0, 0, 0.1164904542, 0, 2.443375475, 0.2125312125, 0, 2.5193659042, -0.28125245, -0.686416096],
    vlt200: [54.960126333, 0, 18.0988965, -0.112886833, 17.500061667, 0, 0, 0.1567865833, 0, -0.277276, 0.88830575, 0, 0.25582125, -0.857066167, -3.244749917],
    orifices: [40],
    angles: [0, 15, 30, 45, 60, 75, 90]
  },
  "TeeJet SS": {
    ccd: { orfSub: 11, orfDiv: 9, asSub: 153, asDiv: 33, pressSub: 58, pressDiv: 35, angSub: 0, angDiv: 1 },
    dv01: [167.618284405659, -10.4984517968544, -125.388963883865, 49.7118255951831, 0, 13.318392298282, -9.43761855623859, -52.8825763343083, 0, 0, 0, 4.5908133905233, 78.2655590566396, -1.48141146188175, 0],
    dv05: [404.573766106937, -5.04881263024502, -265.437565543489, 102.864908311752, 0, 17.9568421444214, -21.1607066779711, -100.259798205726, 0, 0, 0, -1.3739823882621, 163.243939835696, -10.6237390716259, 0],
    dv09: [683.78805147931, 19.8979120135567, -408.285409459618, 130.372868637608, 0, -2.41764018924356, -48.2568359664576, -112.25641515016, 0, 0, 0, -30.0045853067263, 265.382708432272, -45.8721275156206, 0],
    vlt100: [3.08936084931593, 0.426755115037744, 4.16509547838055, -1.74862731089006, 0, 0.35635988661466, -0.0449687585162372, -1.38961131527369, 0, 0, 0, 0.151437927781673, 1.40171018034076, 0.567647342778763, 0],
    vlt200: [12.7682633910758, 0.831140237898505, 14.2480927036038, -5.94123100312058, 0, -0.0902413599716164, 0.424589698495041, -4.15204420349472, 0, 0, 0, 0.387996177150344, 3.87338584903696, 1.85367094774397, 0],
    orifices: [2, 3, 4, 6, 8, 10, 12, 15, 20],
    angles: [0]
  },
  "TeeJet H1 4U": {
    ccd: { orfSub: 11, orfDiv: 9, asSub: 150.5, asDiv: 30.5, pressSub: 59.5, pressDiv: 32.5, angSub: 0, angDiv: 1 },
    dv01: [175.437853461016, -18.6044924350827, -151.667749004899, 70.5564582627997, 0, 2.71557009786158, -7.87622124195325, -74.2530079090809, 0, 0, 0, 13.6479206483442, 95.7360953606207, 3.30124436658505, 0],
    dv05: [428.62194659184, -10.1350094433009, -311.376545850333, 145.917638911788, 0, -6.03880312763069, -13.1511777083731, -144.18533920162, 0, 0, 0, 3.21177094676893, 200.465590331731, -5.57333228453539, 0],
    dv09: [728.163736716632, 12.4456152724171, -440.030307269482, 177.309281734175, 0, -15.725813757613, -32.6941222048558, -157.368230354081, 0, 0, 0, -31.3986297809382, 301.396639018229, -45.0292569310072, 0],
    vlt100: [2.7867372860731, 0.476131908176652, 3.38198647836457, -1.55042843337821, 0, 0.687165809368349, -0.408072262027497, -1.11775292096659, 0, 0, 0, -0.508707254574455, 1.0173772143387, 0.365664378926894, 0],
    vlt200: [11.1689069344945, 0.953297593116211, 11.5176639791819, -5.36039600783653, 0, 0.690011505904996, -0.55113140554438, -3.6008755419678, 0, 0, 0, -1.23551646621331, 2.75311409338252, 1.42423244610484, 0],
    orifices: [2, 3, 4, 6, 8, 10, 12, 15, 20],
    angles: [0]
  }
};


// DV thresholds from Reference Nozzles (USDA bands)
const DV_THRESHOLDS = {
  dv01: [59.5, 110.3, 162.0, 191.7, 226.1, 302.5],
  dv05: [134.4, 248.1, 357.8, 431.0, 500.9, 658.6],
  dv09: [236.4, 409.4, 584.0, 737.1, 819.8, 1142.2]
};

const DSC_LABELS = {
  1: "VERY FINE",
  2: "FINE",
  3: "MEDIUM",
  4: "COARSE",
  5: "VERY COARSE",
  6: "EXT. COARSE",
  7: "ULT. COARSE"
};

function codeVariablesDroplet(cfg, orifice, airspeed, pressure, angle) {
  const c = cfg.ccd;
  const orf   = (orifice  - c.orfSub)   / c.orfDiv;
  const as    = (airspeed - c.asSub)    / c.asDiv;
  const press = (pressure - c.pressSub) / c.pressDiv;
  const ang   = (angle    - c.angSub)   / c.angDiv;
  return { orf, as, press, ang };
}

function evaluateResponseDroplet(coeffs, coded) {
  const { orf, as, press, ang } = coded;
  const [
    B, C, D, E, F,
    G, H, I, J, K,
    L, M, N, O, P
  ] = coeffs;

  return (
    B +
    C * orf + D * as + E * press + F * ang +
    G * orf * as +
    H * orf * press +
    I * as * press +
    J * orf * ang +
    K * as * ang +
    L * press * ang +
    M * orf * orf +
    N * as * as +
    O * press * press +
    P * ang * ang
  );
}

function classifyDVToCode(dv, thresholds) {
  const [vf_f, f_m, m_c, c_vc, vc_xc, xc_uc] = thresholds;

  if (dv >= xc_uc) return 7;
  if (dv >= vc_xc) return 6;
  if (dv >= c_vc)  return 5;
  if (dv >= m_c)   return 4;
  if (dv >= f_m)   return 3;
  if (dv >= vf_f)  return 2;
  if (dv >= 0)     return 1;
  return null;
}

function classifyDSC(dv01, dv05, dv09) {
  const code01 = classifyDVToCode(dv01, DV_THRESHOLDS.dv01);
  const code05 = classifyDVToCode(dv05, DV_THRESHOLDS.dv05);
  const code09 = classifyDVToCode(dv09, DV_THRESHOLDS.dv09);

  const label01 = code01 ? (DSC_LABELS[code01] || "UNKNOWN") : null;
  const label05 = code05 ? (DSC_LABELS[code05] || "UNKNOWN") : null;
  const label09 = code09 ? (DSC_LABELS[code09] || "UNKNOWN") : null;

  if (code01 == null || code05 == null) {
    return {
      overallCode: null,
      overallLabel: "OUT OF RANGE",
      code01, code05, code09,
      label01, label05, label09
    };
  }

  const overallCode = Math.min(code01, code05);
  const overallLabel = DSC_LABELS[overallCode] || "UNKNOWN";

  return {
    overallCode,
    overallLabel,
    code01, code05, code09,
    label01, label05, label09
  };
}
// Decide which nozzle family (if any) should filter droplet suggestions
function getDropletFamilyFilter() {
  const modeSel    = getEl("family");
  const sizingMode = (modeSel && modeSel.value === "multi") ? "multi" : "single";

  if (sizingMode === "single") {
    // Global override in single-nozzle mode; empty means "Best Fit (Any Family)"
    return globalFamilyOverride || "";
  }

  // Multi-nozzle mode: if exactly one unique per-row override exists, use it.
  const vals = Object.values(rowFamilyOverrides || {}).filter(v => v);
  if (!vals.length) return "";
  const unique = Array.from(new Set(vals));
  return unique.length === 1 ? unique[0] : "";
}

// Returns null, or { globalSet: Set<string>, perFamily: { [famKey]: Set<string> } }
function getDropletOrificeFilter() {
  const state = lastSizingState;
  if (!state) return null;

  const allowed = new Set();

  if (state.sizingMode === "single") {
    if (state.nozzleSize != null) {
      allowed.add(String(state.nozzleSize));
    }
  } else if (state.sizingMode === "multi" && state.rowSolutions) {
    Object.values(state.rowSolutions).forEach(sol => {
      if (sol && sol.size != null) {
        allowed.add(String(sol.size));
      }
    });
  }

  // If nothing got added, don't restrict
  return allowed.size ? allowed : null;
}


/**
 * Black-box droplet evaluation for SwathPro.
 * family: droplet family key (must exist in DROPLET_DB)
 * orifice: numeric tip size (e.g. 4, 6, 20)
 * pressure: nozzle pressure (psi) – NOT gauge
 * airspeed: mph
 * angle: nozzle body angle (deg); we’ll use 0° or family default
 */
function evaluateNozzleDroplet(family, orifice, pressure, airspeed, angle) {
  const cfg = DROPLET_DB[family];
  if (!cfg) return null;

  const coded = codeVariablesDroplet(cfg, orifice, airspeed, pressure, angle);

  // Core DV predictions
  const dv01 = evaluateResponseDroplet(cfg.dv01, coded);
  const dv05 = evaluateResponseDroplet(cfg.dv05, coded);
  const dv09 = evaluateResponseDroplet(cfg.dv09, coded);

  // Driftable fines (%<100 µm, %<200 µm)
  let v100 = NaN, v200 = NaN;
  const less100 = cfg.less100 || cfg.vlt100;
  const less200 = cfg.less200 || cfg.vlt200;
  if (less100 && less200) {
    v100 = evaluateResponseDroplet(less100, coded);
    v200 = evaluateResponseDroplet(less200, coded);
  }

  // USDA droplet size category
  const dsc = classifyDSC(dv01, dv05, dv09);

  return {
    dv01,
    dv05,
    dv09,
    v100,
    v200,
    dsc
  };
}


// Map SwathPro nozzle family → droplet family key.
// For now names match; this is here for future alias handling.
function mapFamilyToDropletKey(family) {
  return DROPLET_DB[family] ? family : null;
}

function populateDropletAngles() {
  const angleSel = getEl("dropletAngle");
  const famSel   = getEl("family");
  if (!angleSel || !famSel) return;

  const fam = famSel.value;
  const dropletKey = mapFamilyToDropletKey(fam);
  angleSel.innerHTML = "";

  if (!dropletKey || !DROPLET_DB[dropletKey] || !Array.isArray(DROPLET_DB[dropletKey].angles)) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "Auto";
    angleSel.appendChild(opt);
    return;
  }

  const cfgAngles = DROPLET_DB[dropletKey].angles;
  const optAuto = document.createElement("option");
  optAuto.value = "";
  optAuto.textContent = "Auto";
  angleSel.appendChild(optAuto);

  cfgAngles.forEach(a => {
    const opt = document.createElement("option");
    opt.value = String(a);
    opt.textContent = `${a}°`;
    angleSel.appendChild(opt);
  });
}

function getDropletSearchPressure() {
  const useGaugeEl = getEl("useGaugePsi");
  const headerEl   = getEl("dropletPressureHeader");

  const useGauge = !!(useGaugeEl && useGaugeEl.checked);

  if (headerEl) {
    headerEl.textContent = useGauge ? "Gauge PSI" : "Nozzle PSI";
  }

  // Use the worst-load row (GPA * swath) from the last sizing state
  const state = lastSizingState;
  if (!state || !state.rateRows || !state.rateRows.length) return 0;

  let worstRow  = state.rateRows[0];
  let worstLoad = worstRow.gpa * worstRow.sw;

  for (let i = 1; i < state.rateRows.length; i++) {
    const r    = state.rateRows[i];
    const load = r.gpa * r.sw;
    if (load > worstLoad) {
      worstLoad = load;
      worstRow  = r;
    }
  }

  // For now we always return Gauge PSI; per-nozzle nozzle PSI is computed
  // inside findNozzlesByDSC when needed.
  const gaugePsi = worstRow.psi || 0;
  return gaugePsi;
}

function buildDropletResultsFromSizingState(airspeed) {
  const state = lastSizingState;
  if (!state || !state.rateRows || !state.rateRows.length || !airspeed) return [];

  const useGaugeEl = getEl("useGaugePsi");
  const useGauge   = !!(useGaugeEl && useGaugeEl.checked);

  const rows    = state.rateRows;
  const results = [];

  // We now drive droplet results from:
  //  - the orifice size the sizing engine chose (single or multi)
  //  - all droplet families that support that orifice
  const dropletFamilies = Object.keys(DROPLET_DB);
    // Optional global family filter (single-nozzle mode uses this)
  const famFilterGlobal = getDropletFamilyFilter();

  rows.forEach(row => {
    const gaugePsi = row.psi || 0;
    if (!gaugePsi) return;

    // Per-row droplet target from rate table (drop1/drop2/drop3)
    // row.dsc is already uppercased in getRateRows()
    const rowDsc = (row.dsc || "").trim();

    let rowEffectiveTarget;
    if (!rowDsc) {
      // Blank / "None" → sentinel meaning "return nothing for this row"
      rowEffectiveTarget = "__NONE__";
    } else if (rowDsc === "ALL") {
      // "All" → no DSC filter
      rowEffectiveTarget = "";
    } else {
      // Specific DSC (MEDIUM, COARSE, etc.)
      rowEffectiveTarget = rowDsc;
    }

    const beforeCount = results.length;
    // Determine which orifice(s) apply to this rate row
    const orificesForRow = [];

    if (state.sizingMode === "single") {
      if (state.nozzleSize != null) {
        orificesForRow.push(parseFloat(state.nozzleSize));
      }
    } else if (state.sizingMode === "multi" && state.rowSolutions && state.rowSolutions[row.idx]) {
      const sol = state.rowSolutions[row.idx];
      if (sol && sol.size != null) {
        orificesForRow.push(parseFloat(sol.size));
      }
    }

    if (!orificesForRow.length) return;
	
	    // Family filter for this row:
    //  - single mode: global override (Best Fit = all families)
    //  - multi mode: per-row override if present (Best Fit = all families)
    let famFilterForRow = "";
    if (state.sizingMode === "single") {
      famFilterForRow = famFilterGlobal || "";
    } else if (state.sizingMode === "multi") {
      famFilterForRow = (rowFamilyOverrides && rowFamilyOverrides[row.idx]) || "";
    }

    orificesForRow.forEach(orifice => {
      dropletFamilies.forEach(famKey => {
        const cfgDroplet = DROPLET_DB[famKey];
        if (!cfgDroplet) return;
		
		        // Family filter: when a specific nozzle family is selected for this row,
        // only show droplet results for that family.
        if (famFilterForRow && famKey !== famFilterForRow) return;

        // Need Flow_DB data for Cv and nozzle pressure physics
        const famFlow = FLOW_DB[famKey];
        if (!famFlow) return;

        const orificeKey = String(orifice);

        // Only consider families that actually have this orifice:
        //  - if DROPLET_DB.orifices exists, use that set
        //  - otherwise, fall back to whatever exists in FLOW_DB
        let hasDropletOrifice = true;
        if (Array.isArray(cfgDroplet.orifices)) {
          hasDropletOrifice = cfgDroplet.orifices.includes(orifice);
        } else {
          hasDropletOrifice = !!famFlow[orificeKey];
        }
        if (!hasDropletOrifice) return;

        const flowCfg = famFlow[orificeKey];
        if (!flowCfg || !flowCfg.c) return;

        const tipCv = tipCvFromRating(flowCfg.c);
        if (!tipCv) return;


        const gaugePressure  = gaugePsi;
        const nozzlePressure = nozzlePressureFromGauge(gaugePressure, tipCv);
        const tipPressure    = useGauge ? gaugePressure : nozzlePressure;

        // Angles to evaluate – "Auto": all angles for family, or a default set.
        let anglesToUse = [];
        if (Array.isArray(cfgDroplet.angles) && cfgDroplet.angles.length) {
          anglesToUse = cfgDroplet.angles.slice();
        } else {
          // Fallback: evaluate a standard set of body angles
          anglesToUse = [0, 20, 40, 60, 80];
        }


        anglesToUse.forEach(angle => {
          const data = evaluateNozzleDroplet(famKey, orifice, tipPressure, airspeed, angle);
          if (!data || !data.dsc || !data.dsc.overallLabel) return;

          const labelNorm = data.dsc.overallLabel.toUpperCase();

          // Per-row DSC filter:
          // rowEffectiveTarget = "" → no filter (None/All)
          // otherwise              → must match DSC
          // NONE → return nothing for this row
if (rowEffectiveTarget === "__NONE__") return;

// Specific DSC → must match
if (rowEffectiveTarget && labelNorm !== rowEffectiveTarget) return;

        results.push({
          family:     famKey,
          angle,
          orifice,
          pressure:   tipPressure,
          gaugePsi:   gaugePressure,
          nozzlePsi:  nozzlePressure,
          dv05:       data.dv05,
          v100:       data.v100,
          v200:       data.v200,
          dscLabel:   data.dsc.overallLabel,
          rateIdx:    row.idx
        });
      });
    });
  });

    // If a specific DSC was requested for this rate and we found no matches,
    // add a placeholder row so the user sees that the search ran.
    if (results.length === beforeCount &&
        rowEffectiveTarget &&
        rowEffectiveTarget !== "__NONE__") {

      results.push({
        family:    "",
        angle:     "",
        orifice:   "",
        pressure:  NaN,
        gaugePsi:  NaN,
        nozzlePsi: NaN,
        dv05:      NaN,
        v100:      NaN,
        v200:      NaN,
        dscLabel:  `No ${rowEffectiveTarget} Found`,
        rateIdx:   row.idx
      });
    }
  });

  return results;
}








function refreshDropletSuggestionsFromState(){
  const dropletCard = getEl("dropletSuggestions");
  const body        = getEl("dropletSuggestionsBody");

  if (!dropletCard || !body) return;

  const vHi = parseFloat(getEl("vHi")?.value || "0");
  if (!vHi || !lastSizingState || !lastSizingState.rateRows || !lastSizingState.rateRows.length) {
    dropletCard.style.display = "none";
    body.innerHTML = "";
    return;
  }

  // updates Gauge/Nozzle header
  getDropletSearchPressure();

  // Now driven entirely by per-row droplet category (drop1/drop2/drop3)
  const results = buildDropletResultsFromSizingState(vHi);

  if (!results || !results.length) {
    dropletCard.style.display = "none";
    body.innerHTML = "";
    return;
  }

  renderDropletSuggestions(results);
}










// Supported patterns
const PATTERNS = [
  { id:"all",      label:"All nozzles on",     factor:1.0 },
  { id:"1on1off",  label:"1 on / 1 off",       factor:0.5 },
  { id:"1on2off",  label:"1 on / 2 off",       factor:1/3 }
];

// User overrides: rate index (1–3) → pattern id
const patternOverrides = {};
// User overrides: rate index (1–3) → nozzle family (for future multi-nozzle)
const rowFamilyOverrides = {};
// Global family override in single-nozzle mode
let globalFamilyOverride = "";


// --- Helpers ---
function clamp(v, lo, hi){
  if (isNaN(v)) return lo;
  return Math.min(hi, Math.max(lo, v));
}

function getEl(id){ return document.getElementById(id); }

// --- Aircraft / T-Boom / nozzle count ---
function getTotalNozzles(){
  const aircraft = getEl("aircraft").value;
  const base     = NOZZLE_BASE[aircraft] || 0;

  const tInput   = getEl("tBoomCount");
  let tCount     = parseInt(tInput.value || "0", 10);
  tCount         = clamp(tCount, 0, 6);
  tInput.value   = tCount;

  const total = base + tCount;
  getEl("nozzleCountDisplay").textContent = total || "—";
  return total;
}

// --- Rate blocks ---
// --- Rate blocks ---
function getRateRows(){
  const rows = [];
  for (let i = 1; i <= 3; i++) {
    const gpa = parseFloat(getEl("gpa" + i).value || "0");
    const sw  = parseFloat(getEl("swath" + i).value || "0");
    const psi = parseFloat(getEl("psi"  + i)?.value || "0");

    // USDA droplet requirement for this rate (VERY FINE, FINE, MEDIUM, etc.)
    const rawDrop = getEl("drop" + i) ? getEl("drop" + i).value : "";
    const dsc = rawDrop ? rawDrop.trim().toUpperCase() : "";

    // row is active only if it has rate, swath, and gauge PSI
    if (gpa > 0 && sw > 0 && psi > 0) {
      rows.push({
        idx: i,
        gpa,
        sw,
        psi,
        dsc
      });
    }
  }
  return rows;
}



// Total GPM for a given rate/swath at speed
function totalGpm(gpa, swathFt, mph){
  return (gpa * swathFt * mph) / GPAK;
}

// --- Family / sizing mode ---
function populateFamilies(){
  const famSel = getEl("family");
  if (!famSel) return;

  famSel.innerHTML = "";

  // Single-nozzle best fit
  const optSingle = document.createElement("option");
  optSingle.value = "single";
  optSingle.textContent = "Single Nozzle – Best Fit";
  optSingle.selected = true;
  famSel.appendChild(optSingle);

  // Multi-nozzle best fit (behavior same as single for now; just a mode flag)
  const optMulti = document.createElement("option");
  optMulti.value = "multi";
  optMulti.textContent = "Multi-Nozzle – Best Fit";
  famSel.appendChild(optMulti);
}




// Choose nozzle size from FLOW_DB based on the worst-case rate at max speed.
// familyOverride: "" = Best Fit across all families, otherwise restrict to that family.
// Uses valve/check Cv + tip Cv for nozzle PSI and empirical A/B flow for q100.
// This is the "golden" single-nozzle selector: worst-case rate, all nozzles on.
function pickNozzleSize(familyOverride, totalNozzles, rateRows){
  const vHi = parseFloat(getEl("vHi").value || "0");
  if (!vHi || !rateRows.length || !totalNozzles) return null;

  // Find worst-case row by load (GPA * swath)
  let worstRow  = rateRows[0];
  let worstLoad = worstRow.gpa * worstRow.sw;

  for (let i = 1; i < rateRows.length; i++) {
    const r    = rateRows[i];
    const load = r.gpa * r.sw;
    if (load > worstLoad) {
      worstLoad = load;
      worstRow  = r;
    }
  }

  const gaugePsi = worstRow.psi || 0;
  if (!gaugePsi) return null;

  const famKeys = familyOverride
    ? [familyOverride]
    : Object.keys(FLOW_DB);

  let best = null;

  famKeys.forEach(famKey => {
    const famData = FLOW_DB[famKey];
    if (!famData) return;

    Object.keys(famData).forEach(sizeKey => {
      const coeff = famData[sizeKey];
      if (!coeff) return;

      const nozGpm40 = coeff.c;   // GPM @ 40 psi rating
      if (!nozGpm40) return;

      // Tip Cv from rating and nozzle pressure from gauge Psi
      const tipCv = tipCvFromRating(nozGpm40);
      if (!tipCv) return;

      const Pn = nozzlePressureFromGauge(gaugePsi, tipCv);
      if (!Pn) return;

      // Full-flow per nozzle at Pn using empirical aerial curve (A/B)
      const q100 = nozzleFlowEmpirical(Pn, coeff);
      if (!q100) return;

      // Worst-case total flow at max speed
      const totalFlowWorst = totalGpm(worstRow.gpa, worstRow.sw, vHi);
      if (!totalFlowWorst || totalFlowWorst <= 0) return;

      // All nozzles on for sizing
      const qPerNozzleReq = totalFlowWorst / totalNozzles;
      const dcReq         = qPerNozzleReq / q100;
      const dcPct         = dcReq * 100;

      if (!isFinite(dcPct) || dcPct <= 0) return;
      // Only reject extremely low duty; allow >100% so single-nozzle can still size
      if (dcPct < 30) return;

      const distToOpt = Math.abs(dcPct - DC_OPT);

      const candidate = {
        family:    famKey,
        size:      sizeKey,
        q100,
        nozzlePsi: Pn,
        dcPct,
        distToOpt,
        gaugePsi   // store for recommendation text
      };

      if (!best || distToOpt < best.distToOpt) {
        best = candidate;
      }
    });
  });

  return best;
}

// Per-row nozzle sizing for Multi-Nozzle – Best Fit.
// familyOverride: "" = Best Fit across all families, otherwise restrict to that family.
// Sizes for a single rate row at max speed, using the active-nozzle count
// implied by the row's pattern (if any). "opt" still sizes assuming all nozzles on.
function pickNozzleSizeForRow(familyOverride, totalNozzles, row){
  const vHi = parseFloat(getEl("vHi").value || "0");
  if (!vHi || !row || !totalNozzles) return null;

  const totalFlow = totalGpm(row.gpa, row.sw, vHi);
  if (!totalFlow || totalFlow <= 0) return null;

  const gaugePsi = row.psi || 0;
  if (!gaugePsi) return null;

  // NEW: pattern-aware sizing – use this row's pattern override if present
  let patternFactor = 1.0;
  const overrideId = patternOverrides[row.idx];
  if (overrideId && overrideId !== "opt") {
    const p = PATTERNS.find(p => p.id === overrideId);
    if (p) patternFactor = p.factor;
  }

  const activeNozzles = Math.max(1, Math.round(totalNozzles * patternFactor));

  const famKeys = familyOverride
    ? [familyOverride]
    : Object.keys(FLOW_DB);

  let best = null;

  famKeys.forEach(famKey => {
    const famData = FLOW_DB[famKey];
    if (!famData) return;

    Object.keys(famData).forEach(sizeKey => {
      const coeff = famData[sizeKey];
      if (!coeff) return;

      const nozGpm40 = coeff.c;
      if (!nozGpm40) return;

      const tipCv = tipCvFromRating(nozGpm40);
      if (!tipCv) return;

      const Pn = nozzlePressureFromGauge(gaugePsi, tipCv);
      if (!Pn) return;

      const q100 = nozzleFlowEmpirical(Pn, coeff);
      if (!q100) return;

      // Size the orifice for the PATTERN's active nozzle count
      const qPerNozzleReq = totalFlow / activeNozzles;
      const dcReq         = qPerNozzleReq / q100;
      const dcPct         = dcReq * 100;

      if (!isFinite(dcPct) || dcPct <= 0) return;
      // Only reject extremely low duty; allow >100% so single-nozzle can still size
      if (dcPct > 100 || dcPct < 30) return;

      const distToOpt = Math.abs(dcPct - DC_OPT);

      const candidate = {
        family:    famKey,
        size:      sizeKey,
        q100,
        nozzlePsi: Pn,
        dcPct,
        distToOpt
      };

      if (!best || distToOpt < best.distToOpt) {
        best = candidate;
      }
    });
  });

  return best;
}










// --- Duty classification for pill color ---
function dutyClass(dcPct){
  let cls = "p-green";
  if (dcPct < DC_GOOD_LO || dcPct > DC_GOOD_HI){
    cls = "p-yellow";
  }
  if (dcPct <= 40 || dcPct > 100){
    cls = "p-red";
  }
  return cls;
}

// --- Choose pattern for a given row ---
function computePatternForRow(row, state, forcedPatternId){
  const isMulti = state && state.sizingMode === "multi";

  let q100 = null;

  if (isMulti && state.rowSolutions && state.rowSolutions[row.idx] && state.rowSolutions[row.idx].q100){
    // multi-nozzle: q100 already sized at this row's gauge PSI
    q100 = state.rowSolutions[row.idx].q100;
  } else if (!isMulti && state.family && state.nozzleSize) {
    // single-nozzle: compute q100 at this row's gauge PSI
    const famData = FLOW_DB[state.family];
    const coeff   = famData && famData[state.nozzleSize];
    if (coeff) {
      const nozGpm40 = coeff.c;
      const tipCv    = tipCvFromRating(nozGpm40);
      const gaugePsi = row.psi || 0;
      const Pn       = (tipCv && gaugePsi) ? nozzlePressureFromGauge(gaugePsi, tipCv) : 0;
      if (Pn) {
        q100 = nozzleFlowEmpirical(Pn, coeff);
      }
    }
  }

  if (!q100) {
    // fall back to legacy behavior if anything above fails
    q100 = state.q100;
  }
  const totalNozzles = state.totalNozzles;
  const vHi          = state.vHi;

  if (!q100 || !totalNozzles || !vHi) return null;

  const totalFlow = totalGpm(row.gpa, row.sw, vHi);
  if (!totalFlow || totalFlow <= 0) return null;

  // ---- SPECIAL PATTERN: optimize active nozzles ----
  if (forcedPatternId === "opt") {
    const dcTarget = DC_OPT / 100; // 0.75 target duty
    const ideal = totalFlow / (q100 * dcTarget);

    let activeNozzles = clamp(Math.round(ideal), 1, totalNozzles);
    const qPerNozzleReq = totalFlow / activeNozzles;
    const dcReq = qPerNozzleReq / q100;

    if (!isFinite(dcReq) || dcReq <= 0) return null;  // only reject broken math

    const dcPct = dcReq * 100;

    // Always return result, even if >105% duty
    return {
      id: "opt",
      label: "Optimize active nozzles",
      activeNozzles,
      qPerNozzleReq,
      dcPct,
      distToOpt: Math.abs(dcPct - DC_OPT)
    };
  }

  // ---- FIXED PATTERN LOGIC ----
  let candidates = PATTERNS;

  // Manual override of a fixed pattern
  if (forcedPatternId && forcedPatternId !== "opt") {
    const p = PATTERNS.find(p => p.id === forcedPatternId);
    if (!p) return null;
    candidates = [p];
  }

  let bestUnder105 = null;
  let bestOver105  = null;

  candidates.forEach(p => {
    const activeNozzles = Math.max(1, Math.round(totalNozzles * p.factor));
    const qPerNozzleReq = totalFlow / activeNozzles;
    const dcReq = qPerNozzleReq / q100;

    if (!isFinite(dcReq) || dcReq <= 0) return;

    const dcPct = dcReq * 100;
    const distToOpt = Math.abs(dcPct - DC_OPT);

    const candidate = {
      id: p.id,
      label: p.label,
      activeNozzles,
      qPerNozzleReq,
      dcPct,
      distToOpt
    };

    if (!forcedPatternId) {
      // AUTO: prefer <=105%, but keep >105% as fallback instead of zeroing
      if (dcPct <= 105) {
        if (!bestUnder105 || distToOpt < bestUnder105.distToOpt) {
          bestUnder105 = candidate;
        }
      } else {
        if (!bestOver105 || distToOpt < bestOver105.distToOpt) {
          bestOver105 = candidate;
        }
      }
    } else {
      // Manual fixed pattern (ALL, 1on1off, 1on2off)
      if (!bestUnder105 || distToOpt < bestUnder105.distToOpt) {
        bestUnder105 = candidate;
      }
    }
  });

  if (!forcedPatternId) {
    return bestUnder105 || bestOver105;
  }
  return bestUnder105;
}


// --- Single-nozzle viability warning ---
// Checks:
//  - Max duty with ALL nozzles ON must be <= 100%
//  - Min duty with 1-on-2-off must be >= 60%
function updateSingleNozzleWarning(state){
  const el = getEl("singleWarning");
  if (!el) return;

  // Default: hide warning
  el.style.display = "none";
  el.textContent = "";

  if (!state || state.sizingMode !== "single" || !state.rateRows || !state.rateRows.length) {
    return;
  }

  // Need a valid family + size to evaluate
  if (!state.family || !state.nozzleSize) return;

  let maxAll = -Infinity;
  let min1on2 = Infinity;

  state.rateRows.forEach(row => {
    const pAll = computePatternForRow(row, state, "all");
    const p12 = computePatternForRow(row, state, "1on2off");

    if (pAll && isFinite(pAll.dcPct)) {
      if (pAll.dcPct > maxAll) maxAll = pAll.dcPct;
    }
    if (p12 && isFinite(p12.dcPct)) {
      if (p12.dcPct < min1on2) min1on2 = p12.dcPct;
    }
  });

  if (!isFinite(maxAll) && !isFinite(min1on2)) return;

  const tooHigh = isFinite(maxAll) && maxAll > 100;
  const tooLow  = isFinite(min1on2) && min1on2 < 60;

  if (!tooHigh && !tooLow) return;

  let msg = "Warning: Single-nozzle mode may not cover your full rate range. ";

if (tooHigh && tooLow) {
  msg += `Single-nozzle mode cannot meet both high and low rate requirements.`;
} else if (tooHigh) {
  msg += `Single-nozzle mode exceeds duty limits at higher rates.`;
} else if (tooLow) {
  msg += `Single-nozzle mode falls below duty limits at lower rates.`;
}


  msg += " Consider adjusting rate, swath, pressure, or using Multi-Nozzle – Best Fit.";

  el.textContent = msg;
  el.style.display = "block";
}

// --- Build table ---
function buildTable(state){
  const tableCard = getEl("tableCard");
  const tbody     = getEl("tbody");
  tbody.innerHTML = "";

  if (!state || !state.rateRows.length){
    if (tableCard) tableCard.style.display = "none";
    return;
  }

  if (tableCard) tableCard.style.display = "block";

  const fams = Object.keys(FLOW_DB);

  state.rateRows.forEach(row => {
    const overrideId = patternOverrides[row.idx];

    const computed = computePatternForRow(row, state, overrideId);

    const fallbackId = overrideId || "all";
    const fallbackPattern =
      PATTERNS.find(p => p.id === fallbackId) || PATTERNS[0];

    // Never drop the row; if computePatternForRow fails, show N/A instead of 0%
    const choice = computed || {
      id: fallbackId,
      label: fallbackPattern.label,
      activeNozzles: state.totalNozzles || 0,
      qPerNozzleReq: NaN,
      dcPct: NaN,
      distToOpt: NaN
    };



    const tr = document.createElement("tr");
	
	    // Per-row sizing solution in multi-nozzle mode (if available)
    const rowSol = (state.sizingMode === "multi" &&
                    state.rowSolutions &&
                    state.rowSolutions[row.idx])
      ? state.rowSolutions[row.idx]
      : null;


    // Target GPA
    let td = document.createElement("td");
    td.textContent = row.gpa.toFixed(1);
    tr.appendChild(td);

    // Swath
    td = document.createElement("td");
    td.textContent = row.sw.toFixed(0);
    tr.appendChild(td);

    // Nozzle family (per-row dropdown)
    td = document.createElement("td");
    const famSel = document.createElement("select");
    famSel.className = "family-select";
    famSel.dataset.rateIdx = String(row.idx);

// Selected family:
//  - single mode: only show global override; otherwise stay on "Best Fit (Any Family)"
//  - multi mode: per-row override, falling back to auto-sized family
let selectedFam = "";
if (state.sizingMode === "single") {
  selectedFam = globalFamilyOverride || "";
} else {
  selectedFam = rowFamilyOverrides[row.idx] || "";
}

    // "Best Fit (Any Family)" option
    const optAny = document.createElement("option");
    optAny.value = "";
    optAny.textContent = "Best Fit (Any Family)";
    if (!selectedFam) optAny.selected = true;
    famSel.appendChild(optAny);

    // Specific families
    fams.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      if (name === selectedFam) opt.selected = true;
      famSel.appendChild(opt);
    });

    td.appendChild(famSel);
    tr.appendChild(td);

    // Orifice (selected tip size)
    td = document.createElement("td");
    const orifice = rowSol ? rowSol.size : (state.nozzleSize || "—");
    td.textContent = orifice || "—";
    tr.appendChild(td);


    // Pattern (dropdown)
    td = document.createElement("td");
    const sel = document.createElement("select");
    sel.className = "pattern-select";
    sel.dataset.rateIdx = String(row.idx);

    PATTERNS.forEach(p => {
      const opt = document.createElement("option");
      opt.value = p.id;
      opt.textContent = p.label;
      if (p.id === choice.id) opt.selected = true;
      sel.appendChild(opt);
    });

    const optAuto = document.createElement("option");
    optAuto.value = "opt";
    optAuto.textContent = "Optimize active nozzles";
    if (choice.id === "opt") optAuto.selected = true;
    sel.appendChild(optAuto);

    td.appendChild(sel);
    tr.appendChild(td);

    // Active nozzles
    td = document.createElement("td");
    td.textContent = choice.activeNozzles.toString();
    tr.appendChild(td);

    // Duty cycle (pill)
    td = document.createElement("td");
    const pill = document.createElement("span");

    if (!isFinite(choice.dcPct)) {
      pill.className = "pill p-red";
      pill.textContent = "N/A";
    } else {
      pill.className = "pill " + dutyClass(choice.dcPct);
      pill.textContent = choice.dcPct.toFixed(0) + "%";
    }

    td.appendChild(pill);
    tr.appendChild(td);


// Nozzle PSI
td = document.createElement("td");
let nozzlePsi = null;

if (rowSol && rowSol.nozzlePsi != null) {
  // multi-nozzle: already per-rate
  nozzlePsi = rowSol.nozzlePsi;
} else if (state.sizingMode === "single" && state.family && state.nozzleSize) {
  // single-nozzle: recompute nozzle psi for this row from gauge psi
  const famData = FLOW_DB[state.family];
  const coeff   = famData && famData[state.nozzleSize];
  if (coeff) {
    const nozGpm40 = coeff.c;
    const tipCv    = tipCvFromRating(nozGpm40);
    const gaugePsi = row.psi || 0;
    nozzlePsi      = (tipCv && gaugePsi) ? nozzlePressureFromGauge(gaugePsi, tipCv) : null;
  }
}

// fallback if we somehow still don't have it
if (nozzlePsi == null && state.nozzlePsi != null) {
  nozzlePsi = state.nozzlePsi;
}

td.textContent = nozzlePsi != null ? nozzlePsi.toFixed(0) : "—";
tr.appendChild(td);



    tbody.appendChild(tr);
  });
}


// --- Recommendation summary ---
function updateRecommendation(state, nozzle){
  const recCard  = getEl("recCard");
  const recText  = getEl("recText");
  const recNotes = getEl("recNotes");

  // Panel is gone in new layout – bail out quietly
  if (!recCard || !recText || !recNotes) return;

  if (!state || !nozzle){
    recCard.style.display = "none";
    recText.textContent   = "";
    recNotes.textContent  = "";
    return;
  }

  recCard.style.display = "block";

const fam  = state.family;
const psi  = state.gaugePsi != null ? state.gaugePsi : 0;
const size = nozzle.size;
const aircraft = getEl("aircraft").value;
const vHi      = state.vHi;

recText.textContent = psi
  ? `Model nozzle at ${psi} psi on ${aircraft}, sized so worst-case rate runs ~${DC_OPT}% duty.`
  : `Model nozzle on ${aircraft}, sized so worst-case rate runs ~${DC_OPT}% duty.`;


  recNotes.textContent =
    `Nozzle sized on worst-case rate at ${vHi} mph, targeting ~${DC_OPT}% duty. ` +
    `Patterns above show duty for each rate using the same nozzle.`;
}


// --- Render USDA droplet suggestions mini-table ---
function renderDropletSuggestions(results) {
  const wrap = getEl("dropletSuggestions");
  const body = getEl("dropletSuggestionsBody");
  if (!wrap || !body) return;

  body.innerHTML = "";

  if (!results || !results.length) {
    wrap.style.display = "none";
    return;
  }

  results.forEach((r, idx) => {
    const tr = document.createElement("tr");
    // Rate-based coloring: R1, R2, R3 share colors
const rowClass = r.rateIdx ? `dsc-rate-${r.rateIdx}` : "dsc-rate-none";
tr.classList.add("dsc-colored", rowClass);
    tr.innerHTML = `
      <td>${r.family}</td>
      <td style="text-align:left;">${r.rateIdx ? "R" + r.rateIdx : ""}</td>
      <td style="text-align:right;">${Number.isFinite(r.pressure) ? r.pressure.toFixed(0) : "–"}</td>
      <td style="text-align:right;">${r.angle}&deg;</td>
      <td style="text-align:right;">${r.orifice}</td>
      <td style="text-align:right;">${Number.isFinite(r.dv05) ? r.dv05.toFixed(0) : "–"}</td>
      <td style="text-align:right;">${Number.isFinite(r.v100) ? r.v100.toFixed(1) + "%" : "–"}</td>
      <td style="text-align:right;">${Number.isFinite(r.v200) ? r.v200.toFixed(1) + "%" : "–"}</td>
      <td>${r.dscLabel}</td>
    `;
    body.appendChild(tr);
  });

  wrap.style.display = "block";
}




// --- Main calc ---
function doCalc(){
  const totalNozzles = getTotalNozzles();

  const vInput = getEl("vHi");
  let vHi = parseFloat(vInput?.value || "0");
  vHi = clamp(vHi, 0, 220);        // hard cap at 220 mph
  if (vInput) vInput.value = vHi || "";  // write clamped value back to the box

  const rows = getRateRows();

  const modeSel    = getEl("family");
  const sizingMode = (modeSel && modeSel.value === "multi") ? "multi" : "single";

  const prevState = lastSizingState || null;
  const prevMode  = prevState ? prevState.sizingMode : null;

  // NEW: if sizing mode changed (single ↔ multi), clear pattern overrides
  if (prevMode && prevMode !== sizingMode) {
    Object.keys(patternOverrides).forEach(k => delete patternOverrides[k]);
  }

  if (!totalNozzles || !vHi || !rows.length){
    updateRecommendation(null, null);
    updateDropletSummary(null, null);
    lastSizingState = null;
    lastSizedNozzle = null;
    updateSingleNozzleWarning(null);
    buildTable(null);
    return;
  }



  let nozzle = null;

  const state = {
    vHi,
    totalNozzles,
    rateRows:     rows,
    q100:         null,
    nozzleSize:   null,
    nozzlePsi:    null,
    gaugePsi:     null,
    family:       "",
    sizingMode,
    rowSolutions: null
  };

if (sizingMode === "single") {
  const famOverride = globalFamilyOverride || "";
  nozzle = pickNozzleSize(famOverride, totalNozzles, rows);

  // NEW: if nozzle size changed vs previous single-nozzle run, reset patterns
  if (nozzle) {
    const prevSize =
      (lastSizingState && lastSizingState.sizingMode === "single")
        ? lastSizingState.nozzleSize
        : null;

    if (prevSize != null && nozzle.size !== prevSize) {
      Object.keys(patternOverrides).forEach(k => delete patternOverrides[k]);
    }
  }

  if (nozzle){
    state.family     = nozzle.family;
    state.q100       = nozzle.q100;     // q100 at worst-row PSI (used as fallback)
    state.nozzleSize = nozzle.size;
    state.nozzlePsi  = nozzle.nozzlePsi;
    state.gaugePsi   = nozzle.gaugePsi || null;
  }

} else {
    const rowSolutions = {};

    rows.forEach(row => {
      const famOverride = rowFamilyOverrides[row.idx] || "";
      const sol = pickNozzleSizeForRow(famOverride, totalNozzles, row);
      if (sol) {
        rowSolutions[row.idx] = sol;
      }
    });

    state.rowSolutions = rowSolutions;
  }
  
    if (sizingMode === "single") {
    if (!nozzle || !state.q100){
      buildTable(null);
      return;
    }

    // NEW: if the selected orifice changed in single-nozzle mode,
    // wipe pattern overrides so patterns are re-picked for the new tip size.
    const prevSize =
      (prevState && prevState.sizingMode === "single")
        ? prevState.nozzleSize
        : null;

    if (prevSize != null &&
        state.nozzleSize != null &&
        state.nozzleSize !== prevSize) {
      Object.keys(patternOverrides).forEach(k => delete patternOverrides[k]);
    }

  } else {
    if (!state.rowSolutions || !Object.keys(state.rowSolutions).length){
      buildTable(null);
      return;
    }
  }

  updateRecommendation(state, nozzle);
  lastSizingState = state;
  updateSingleNozzleWarning(state);


  if (sizingMode === "single") {
    if (!nozzle || !state.q100){
      buildTable(null);
      return;
    }
  } else {
    if (!state.rowSolutions || !Object.keys(state.rowSolutions).length){
      buildTable(null);
      return;
    }
  }

  buildTable(state);
  refreshDropletSuggestionsFromState();
}




// --- Wire events ---
document.addEventListener("DOMContentLoaded", () => {
  populateFamilies();
  populateDropletAngles();
  getTotalNozzles();
  doCalc();
  refreshDropletSuggestionsFromState();

  // aircraft / T-Boom / speed
  getEl("aircraft").addEventListener("change", () => { getTotalNozzles(); doCalc(); refreshDropletSuggestionsFromState(); });
  getEl("tBoomCount").addEventListener("input", () => { getTotalNozzles(); doCalc(); refreshDropletSuggestionsFromState(); });
  getEl("vHi").addEventListener("input", () => { doCalc(); refreshDropletSuggestionsFromState(); });

// rates + swaths + per-rate PSI
["gpa1","gpa2","gpa3","swath1","swath2","swath3","psi1","psi2","psi3"].forEach(id => {
  const el = getEl(id);
  if (el) el.addEventListener("input", () => {
    doCalc();
    refreshDropletSuggestionsFromState();
  });
});

  // Per-rate droplet category (drop1 / drop2 / drop3)
  document.querySelectorAll(".droplet-select").forEach(el => {
    el.addEventListener("change", () => {
      doCalc();
      refreshDropletSuggestionsFromState();
    });
  });

// family (global sizing mode / family choice)
["family"].forEach(id => {
  const el = getEl(id);
  if (!el) return;

  el.addEventListener("change", () => {
    if (id === "family") {
      populateDropletAngles();
    }
    doCalc();
    refreshDropletSuggestionsFromState();
  });
});
  
    // Target Droplet Category -> refresh suggestions on change
  const targetSel = getEl("targetDsc");
  if (targetSel) {
    targetSel.addEventListener("change", () => {
      refreshDropletSuggestionsFromState();
    });
  }

// pattern + family dropdowns (event delegation)
getEl("tbody").addEventListener("change", (evt) => {
  const t = evt.target;
  if (!t) return;

  // Pattern select
  if (t.classList.contains("pattern-select")) {
    const idx = parseInt(t.dataset.rateIdx || "0", 10);
    if (!idx) return;
    const val = t.value;
    if (val === "opt" || PATTERNS.some(p => p.id === val)) {
      patternOverrides[idx] = val;
    } else {
      delete patternOverrides[idx];
    }
    doCalc();
    refreshDropletSuggestionsFromState();
    return;
  }

  // Nozzle family select
  if (t.classList.contains("family-select")) {
    const idx = parseInt(t.dataset.rateIdx || "0", 10);
    if (!idx) return;

    const modeSel    = getEl("family");
    const sizingMode = (modeSel && modeSel.value === "multi") ? "multi" : "single";
    const famValue   = t.value || "";

  if (sizingMode === "single") {
    // In single-nozzle mode, any row change is a global override
    globalFamilyOverride = famValue;
    // Keep all row dropdowns in sync
    document.querySelectorAll("#tbody .family-select").forEach(sel => {
      sel.value = famValue;
    });
  } else {
    // In multi-nozzle mode:
    //  - a non-empty value sets a per-row family override
    //  - "Best Fit (Any Family)" (empty) clears the override
    if (famValue) {
      rowFamilyOverrides[idx] = famValue;
    } else {
      delete rowFamilyOverrides[idx];
    }
  }

  doCalc();
  refreshDropletSuggestionsFromState();
  }
});



  // Open Droplet Model button
  const openDropletBtn = getEl("openDropletTool");
  if (openDropletBtn) {
    openDropletBtn.addEventListener("click", () => {
      // adjust path if needed
      window.open("DropletData GC - Calculator_Find Nozzle.html", "_blank");
    });
  }
 
  // Gauge vs nozzle PSI toggle for droplet suggestions
  const useGaugeEl = getEl("useGaugePsi");
  if (useGaugeEl) {
    useGaugeEl.addEventListener("change", () => {
      refreshDropletSuggestionsFromState();
    });
  }


  // NOTE: no more "Suggest Nozzles" button – table updates automatically
});





